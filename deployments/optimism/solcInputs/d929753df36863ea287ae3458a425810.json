{
  "language": "Solidity",
  "sources": {
    "contracts/LiquidityGenerator.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\nimport './interfaces/IERC20.sol';\nimport './interfaces/IOwnedDistributor.sol';\nimport './interfaces/IVelodromeGauge.sol';\nimport './interfaces/IVelodromePairFactory.sol';\nimport './interfaces/IVelodromeRouter.sol';\nimport './interfaces/IVelodromeVoter.sol';\nimport './libraries/SafeMath.sol';\nimport './libraries/SafeToken.sol';\n\ncontract LiquidityGenerator {\n    using SafeMath for uint256;\n    using SafeToken for address;\n\n    struct ConstuctorParams {\n        address admin_;\n        address sonne_;\n        address usdc_;\n        address velo_;\n        address router0_;\n        address voter_;\n        address reservesManager_;\n        address distributor_;\n        address bonusDistributor_;\n        uint256 periodBegin_;\n        uint256 periodDuration_;\n        uint256 bonusDuration_;\n    }\n\n    uint256 public constant lockDuration = 6 * 30 * 24 * 60 * 60; // 6 months\n\n    address public immutable admin;\n    address public immutable sonne;\n    address public immutable usdc;\n    address public immutable velo;\n    address public immutable router0;\n    address public immutable voter;\n    address public immutable distributor;\n    address public immutable bonusDistributor;\n    uint256 public immutable periodBegin;\n    uint256 public immutable periodEnd;\n    uint256 public immutable bonusEnd;\n    uint256 public unlockTimestamp;\n    bool public finalized = false;\n    bool public delivered = false;\n    address public reservesManager;\n\n    // Generated velodrome addresses\n    address public immutable pair0;\n    address public immutable gauge;\n\n    event Finalized(uint256 amountSonne, uint256 amountUSDC);\n    event Deposit(\n        address indexed sender,\n        uint256 amount,\n        uint256 distributorTotalShares,\n        uint256 bonusDistributorTotalShares,\n        uint256 newShares,\n        uint256 newBonusShares\n    );\n    event PostponeUnlockTimestamp(\n        uint256 prevUnlockTimestamp,\n        uint256 unlockTimestamp\n    );\n    event Delivered(uint256 amountPair0);\n    event VeloRewardClaimed(uint256 amountVelo);\n\n    constructor(ConstuctorParams memory params_) {\n        require(\n            params_.periodDuration_ > 0,\n            'LiquidityGenerator: INVALID_PERIOD_DURATION'\n        );\n        require(\n            params_.bonusDuration_ > 0 &&\n                params_.bonusDuration_ <= params_.periodDuration_,\n            'LiquidityGenerator: INVALID_BONUS_DURATION'\n        );\n        admin = params_.admin_;\n        sonne = params_.sonne_;\n        usdc = params_.usdc_;\n        velo = params_.velo_;\n        router0 = params_.router0_;\n        voter = params_.voter_;\n        reservesManager = params_.reservesManager_;\n        distributor = params_.distributor_;\n        bonusDistributor = params_.bonusDistributor_;\n        periodBegin = params_.periodBegin_;\n        periodEnd = params_.periodBegin_.add(params_.periodDuration_);\n        bonusEnd = params_.periodBegin_.add(params_.bonusDuration_);\n\n        address _pair0 = _createPair(\n            params_.router0_,\n            params_.sonne_,\n            params_.usdc_\n        );\n        address _gauge = _createGauge(params_.voter_, _pair0);\n\n        pair0 = _pair0;\n        gauge = _gauge;\n    }\n\n    function distributorTotalShares()\n        public\n        view\n        returns (uint256 totalShares)\n    {\n        return IOwnedDistributor(distributor).totalShares();\n    }\n\n    function bonusDistributorTotalShares()\n        public\n        view\n        returns (uint256 totalShares)\n    {\n        return IOwnedDistributor(bonusDistributor).totalShares();\n    }\n\n    function distributorRecipients(address account)\n        public\n        view\n        returns (\n            uint256 shares,\n            uint256 lastShareIndex,\n            uint256 credit\n        )\n    {\n        return IOwnedDistributor(distributor).recipients(account);\n    }\n\n    function bonusDistributorRecipients(address account)\n        public\n        view\n        returns (\n            uint256 shares,\n            uint256 lastShareIndex,\n            uint256 credit\n        )\n    {\n        return IOwnedDistributor(bonusDistributor).recipients(account);\n    }\n\n    function setReserveManager(address reserveManager_) external {\n        require(msg.sender == admin, 'LiquidityGenerator: FORBIDDEN');\n        require(\n            reserveManager_ != address(0),\n            'LiquidityGenerator: INVALID_ADDRESS'\n        );\n        reservesManager = reserveManager_;\n    }\n\n    function postponeUnlockTimestamp(uint256 newUnlockTimestamp) public {\n        require(msg.sender == admin, 'LiquidityGenerator: UNAUTHORIZED');\n        require(\n            newUnlockTimestamp > unlockTimestamp,\n            'LiquidityGenerator: INVALID_UNLOCK_TIMESTAMP'\n        );\n        uint256 prevUnlockTimestamp = unlockTimestamp;\n        unlockTimestamp = newUnlockTimestamp;\n        emit PostponeUnlockTimestamp(prevUnlockTimestamp, unlockTimestamp);\n    }\n\n    function deliverLiquidityToReservesManager() public {\n        require(msg.sender == admin, 'LiquidityGenerator: UNAUTHORIZED');\n        require(!delivered, 'LiquidityGenerator: ALREADY_DELIVERED');\n        require(finalized, 'LiquidityGenerator: NOT_FINALIZED');\n        uint256 blockTimestamp = getBlockTimestamp();\n        require(\n            blockTimestamp >= unlockTimestamp,\n            'LiquidityGenerator: STILL_LOCKED'\n        );\n        IVelodromeGauge(gauge).withdrawAll();\n        uint256 _amountPair0 = pair0.myBalance();\n        pair0.safeTransfer(reservesManager, _amountPair0);\n        delivered = true;\n        emit Delivered(_amountPair0);\n    }\n\n    function claimVeloRewards() public {\n        require(msg.sender == admin, 'LiquidityGenerator: UNAUTHORIZED');\n        require(finalized, 'LiquidityGenerator: NOT_FINALIZED');\n\n        address[] memory tokens = new address[](1);\n        tokens[0] = velo;\n        IVelodromeGauge(gauge).getReward(address(this), tokens);\n\n        uint256 _amountVelo = velo.myBalance();\n        velo.safeTransfer(reservesManager, _amountVelo);\n        emit VeloRewardClaimed(_amountVelo);\n    }\n\n    function finalize() public {\n        require(!finalized, 'LiquidityGenerator: FINALIZED');\n        uint256 blockTimestamp = getBlockTimestamp();\n        require(blockTimestamp >= periodEnd, 'LiquidityGenerator: TOO_SOON');\n\n        uint256 _amountSonne = sonne.myBalance();\n        uint256 _amountUSDC = usdc.myBalance();\n\n        sonne.safeApprove(router0, _amountSonne);\n        usdc.safeApprove(router0, _amountUSDC);\n        IVelodromeRouter(router0).addLiquidity(\n            sonne,\n            usdc,\n            false,\n            _amountSonne,\n            _amountUSDC,\n            _amountSonne,\n            _amountUSDC,\n            address(this),\n            blockTimestamp\n        );\n\n        uint256 _amountPair0 = pair0.myBalance();\n        pair0.safeApprove(gauge, _amountPair0);\n        IVelodromeGauge(gauge).deposit(_amountPair0, 0);\n\n        unlockTimestamp = blockTimestamp.add(lockDuration);\n        finalized = true;\n        emit Finalized(_amountSonne, _amountUSDC);\n    }\n\n    function deposit(uint256 amountUSDC) external payable {\n        uint256 blockTimestamp = getBlockTimestamp();\n        require(blockTimestamp >= periodBegin, 'LiquidityGenerator: TOO_SOON');\n        require(blockTimestamp < periodEnd, 'LiquidityGenerator: TOO_LATE');\n        require(amountUSDC >= 1e7, 'LiquidityGenerator: INVALID_VALUE'); // minimum 10 USDC\n\n        // Pull usdc to this contract\n        usdc.safeTransferFrom(msg.sender, address(this), amountUSDC);\n\n        (uint256 _prevSharesBonus, , ) = IOwnedDistributor(bonusDistributor)\n            .recipients(msg.sender);\n        uint256 _newSharesBonus = _prevSharesBonus;\n        if (blockTimestamp < bonusEnd) {\n            _newSharesBonus = _prevSharesBonus.add(amountUSDC);\n            IOwnedDistributor(bonusDistributor).editRecipient(\n                msg.sender,\n                _newSharesBonus\n            );\n        }\n        (uint256 _prevShares, , ) = IOwnedDistributor(distributor).recipients(\n            msg.sender\n        );\n        uint256 _newShares = _prevShares.add(amountUSDC);\n        IOwnedDistributor(distributor).editRecipient(msg.sender, _newShares);\n        emit Deposit(\n            msg.sender,\n            amountUSDC,\n            distributorTotalShares(),\n            bonusDistributorTotalShares(),\n            _newShares,\n            _newSharesBonus\n        );\n    }\n\n    receive() external payable {\n        revert('LiquidityGenerator: BAD_CALL');\n    }\n\n    function getBlockTimestamp() public view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    function _createPair(\n        address router_,\n        address sonne_,\n        address usdc_\n    ) internal returns (address) {\n        address _veloPairFactory = IVelodromeRouter(router_).factory();\n        address _pair = IVelodromePairFactory(_veloPairFactory).getPair(\n            sonne_,\n            usdc_,\n            false\n        );\n        if (_pair != address(0)) return _pair;\n\n        _pair = IVelodromePairFactory(_veloPairFactory).createPair(\n            sonne,\n            usdc,\n            false\n        );\n\n        return _pair;\n    }\n\n    function _createGauge(address voter_, address pair0_)\n        internal\n        returns (address)\n    {\n        address _gauge = IVelodromeVoter(voter_).gauges(pair0_);\n        if (_gauge != address(0)) return _gauge;\n\n        _gauge = IVelodromeVoter(voter_).createGauge(pair0_);\n\n        return _gauge;\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IOwnedDistributor.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.5.0;\n\ninterface IOwnedDistributor {\n    function totalShares() external view returns (uint256);\n\n    function recipients(address)\n        external\n        view\n        returns (\n            uint256 shares,\n            uint256 lastShareIndex,\n            uint256 credit\n        );\n\n    function editRecipient(address account, uint256 shares) external;\n}\n"
    },
    "contracts/interfaces/IVelodromeGauge.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.5.0;\n\ninterface IVelodromeGauge {\n    function deposit(uint256 amount, uint256 tokenId) external;\n\n    function withdrawAll() external;\n\n    function withdraw(uint256 amount) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function getReward(address account, address[] calldata tokens) external;\n}\n"
    },
    "contracts/interfaces/IVelodromePairFactory.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.5.0;\n\ninterface IVelodromePairFactory {\n    function createPair(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external returns (address pair);\n\n    function getPair(\n        address tokenA,\n        address tokenB,\n        bool stable\n    ) external view returns (address pair);\n}\n"
    },
    "contracts/interfaces/IVelodromeRouter.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.5.0;\n\ninterface IVelodromeRouter {\n    function factory() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n}\n"
    },
    "contracts/interfaces/IVelodromeVoter.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.5.0;\n\ninterface IVelodromeVoter {\n    function gauges(address _pool) external view returns (address);\n\n    function claimable(address _gauge) external view returns (uint256);\n\n    function createGauge(address _pool) external returns (address);\n\n    function whitelist(address token) external;\n\n    function distribute(address _gauge) external;\n\n    function vote(\n        uint256 tokenId,\n        address[] calldata _poolVote,\n        uint256[] calldata _weights\n    ) external;\n\n    function votes(uint256 _tokenId, address _pool) external view returns (uint256);\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/libraries/SafeToken.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.10;\n\ninterface ERC20Interface {\n    function balanceOf(address user) external view returns (uint256);\n}\n\nlibrary SafeToken {\n    function myBalance(address token) internal view returns (uint256) {\n        return ERC20Interface(token).balanceOf(address(this));\n    }\n\n    function balanceOf(address token, address user) internal view returns (uint256) {\n        return ERC20Interface(token).balanceOf(user);\n    }\n\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), '!safeApprove');\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), '!safeTransfer');\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), '!safeTransferFrom');\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, '!safeTransferETH');\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}